// Code generated by cool go-validate tool; DO NOT EDIT.
package models

import (
	"fmt"
	"log"
	"regexp"
	"strconv"
	"strings"
)

type ValidationError struct {
	Field	string
	Err	error
}

func (u User) Validate() ([]ValidationError, error) {
	res := []ValidationError{}
	var err error
	var ok bool
	if ok, err = valLen([]string{string(u.ID)},36); !ok { res=append(res,ValidationError{"ID",fmt.Errorf("len:36")})}
	if ok, err = valMin([]int{int(u.Age)},18); !ok { res=append(res,ValidationError{"Age",fmt.Errorf("min:18")})}
	if ok, err = valMax([]int{int(u.Age)},50); !ok { res=append(res,ValidationError{"Age",fmt.Errorf("max:50")})}
	if ok, err = valRegexp([]string{string(u.Email)},`^\w+@\w+\.\w+$`); !ok { res=append(res,ValidationError{"Email",fmt.Errorf(`regexp:^\w+@\w+\.\w+$`)})}
	if ok, err = valInString([]string{string(u.Role)},`admin,stuff`); !ok { res=append(res,ValidationError{"Role",fmt.Errorf(`in:admin,stuff`)})}
	if ok, err = valLen(u.Phones,11); !ok { res=append(res,ValidationError{"Phones",fmt.Errorf("len:11")})}
	if ok, err = valInInt([]int{int(u.Response.Code)},`200,404,500`); !ok { res=append(res,ValidationError{"Response.Code",fmt.Errorf("in:200,404,500")})}
	log.Println(ok)
	return res, err
}

func (u App) Validate() ([]ValidationError, error) {
	res := []ValidationError{}
	var err error
	var ok bool
	if ok, err = valLen([]string{string(u.Version)},5); !ok { res=append(res,ValidationError{"Version",fmt.Errorf("len:5")})}
	log.Println(ok)
	return res, err
}

func (u Response) Validate() ([]ValidationError, error) {
	res := []ValidationError{}
	var err error
	var ok bool
	if ok, err = valInInt([]int{int(u.Code)},`200,404,500`); !ok { res=append(res,ValidationError{"Code",fmt.Errorf("in:200,404,500")})}
	log.Println(ok)
	return res, err
}


func valLen(s []string, n int) (bool,error) {
	res := true
	for _,v :=range s {
		if len(v)!=n {
			res=false
			break
		}
	}
	return res,nil
}

func valMin(i []int, n int) (bool,error) {
	res := true
	for _,v :=range i {
		if v<n {
			res=false
			break
		}
	}
	return res,nil
}

func valMax(i []int, n int) (bool,error) {
	res := true
	for _,v :=range i {
		if v>n {
			res=false
			break
		}
	}
	return res,nil
}

func valRegexp(s []string, r string) (bool,error) {
	res := true
	var err error
	rg := regexp.MustCompile(r)
	for _,v :=range s {
		if !rg.MatchString(v) {
			res=false
			break
		}
	}
	return res,err
}

func valInString(s []string, r string) (bool,error) {
	i := false
	for _,k :=range s {
		i = false
		for _, v := range strings.Split(r, ",") {
			if k == v {
				i = true
			}
		}
		if !i { break }
	}
	return i, nil
}

func valInInt(s []int, r string) (bool,error) {
	i := false
	var err error
	var m int
	for _,k :=range s {
		i = false
		for _, v := range strings.Split(r, ",") {
			m,err=strconv.Atoi(v)
			if k == m { i = true }
		}
		if !i { break }
	}
	return i, err
}
